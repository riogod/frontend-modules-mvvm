# Архитектура платформы

Modular Frontend Platform (MFP) объединяет принципы [чистой архитектуры](./clear-architecture.md), модульности и паттерна MVVM для построения масштабируемых frontend-приложений.

## Архитектурные цели

Архитектура платформы направлена на решение конкретных задач:

| Задача                 | Решение                                                      |
| ---------------------- | ------------------------------------------------------------ |
| Независимая разработка | Модули изолированы и могут разрабатываться разными командами |
| Тестируемость          | Слои разделены, зависимости инвертированы                    |
| Масштабирование        | Новые модули добавляются без изменения существующих          |
| Поддержка кода         | Единая структура и подходы во всех модулях                   |
| Гибкость UI            | Бизнес-логика отделена от представления                      |

## Ключевые концепции

### Модульность

Приложение состоит из независимых модулей. Каждый модуль:

- Содержит полный функционал одной бизнес-области
- Имеет собственную конфигурацию, роуты, переводы
- Загружается по требованию или при старте
- Взаимодействует с другими модулями через общие абстракции

Модульность обеспечивает параллельную разработку командами и независимое развертывание функциональности.

### Инверсия зависимостей

Компоненты зависят от абстракций, а не от конкретных реализаций. Платформа использует DI-контейнер для разрешения зависимостей:

- Модули получают сервисы через инъекцию
- Реализации легко заменяются (например, для тестов)
- Связность между компонентами минимальна

### Инкапсуляция

Функционал сосредоточен внутри модуля:

- Модуль не требует внешней конфигурации
- Все настройки определены в конфигурации модуля
- Внутренняя структура скрыта от других модулей

### Реактивность

Изменения данных автоматически отражаются в UI:

- Состояние хранится в наблюдаемых структурах
- Компоненты подписываются на изменения
- Обновления происходят точечно, без лишних перерисовок

Реактивность упрощает реализацию optimistic UI — интерфейс реагирует мгновенно, не дожидаясь ответа сервера.

## Слои платформы

```
┌─────────────────────────────────────────┐
│           Host Application              │
│  ┌───────────────────────────────────┐  │
│  │         Libraries                 │  │
│  └───────────────────────────────────┘  │
└───────────────┬─────────────────────────┘
                │
                │ shared scope
                │
┌───────────────▼─────────────────────────┐
│              Modules                    │
│  ┌────────────────────────────────────┐ │
│  │   Model → ViewModel → View         │ │
│  └────────────────────────────────────┘ │
└─────────────────────────────────────────┘
```

**Host Application** координирует работу системы: инициализирует платформу, загружает модули, предоставляет инфраструктуру. Хост не содержит бизнес-логики сам по себе — только механизмы платформы, при этом если строится приложение на локальных модулях - то бизнес функционал должен быть сосредоточен в них.

**Libraries** предоставляют инфраструктурные возможности: работу с API, управление состоянием, UI-компоненты. Хост использует библиотеки и делает их доступными модулям через shared scope.

**Modules** содержат бизнес-логику приложения. Каждый модуль организован по паттерну MVVM и получает инфраструктуру от хоста.

## MVVM в модулях

Каждый модуль внутри организован по паттерну Model-View-ViewModel:

```
┌─────────────────────────────────────────────────────┐
│                      Module                         │
│                                                     │
│  ┌─────────┐    ┌─────────────┐    ┌─────────────┐  │
│  │  Model  │◄───│  ViewModel  │◄───│    View     │  │
│  └─────────┘    └─────────────┘    └─────────────┘  │
│       ▲               ▲                             │
│       │               │                             │
│  ┌─────────┐    ┌─────────────┐                     │
│  │  Data   │    │  Use Cases  │                     │
│  └─────────┘    └─────────────┘                     │
│                                                     │
└─────────────────────────────────────────────────────┘
```

**Model** — хранит данные и состояние. Реактивен, оповещает подписчиков об изменениях.

**ViewModel** — содержит логику представления. Трансформирует данные модели для отображения, обрабатывает действия пользователя.

**View** — отображает данные. Подписан на ViewModel, не содержит бизнес-логики.

**Use Cases** — инкапсулируют бизнес-операции. Координируют работу с моделями и внешними сервисами.

**Data** — слой адаптеров для работы с внешними источниками (API, storage). Использует паттерн Repository.

## Взаимодействие модулей

Модули взаимодействуют через общие абстракции, не зная о внутренней реализации друг друга:

- **Shared Models** — модели, доступные нескольким модулям
- **Shared Components** — UI-компоненты, предоставляемые одним модулем другим
- **Events** — реактивные подписки на изменения общих сущностей

DI-контейнер служит точкой интеграции: модуль регистрирует свои сервисы, другие модули получают их через инъекцию.

## Разделение ответственности

| Слой      | Ответственность                    | Не должен               |
| --------- | ---------------------------------- | ----------------------- |
| View      | Отображение, пользовательский ввод | Содержать бизнес-логику |
| ViewModel | Логика представления, состояние UI | Знать о View            |
| Model     | Хранение данных, бизнес-правила    | Зависеть от UI          |
| Use Case  | Координация бизнес-операций        | Знать о представлении   |
| Data      | Работа с внешними источниками      | Содержать бизнес-логику |

## Преимущества подхода

**Для разработки:**

- Команды работают над модулями параллельно
- Изменения в одном модуле не ломают другие
- Код легко тестировать на всех уровнях
- Разработка с бекенд частью может вестись паралельно

**Для поддержки:**

- Единая структура во всех модулях
- Понятно, где искать определенную логику
- Рефакторинг локализован внутри модуля

**Для масштабирования:**

- Новые модули добавляются без изменения ядра
- Модули загружаются по требованию
- Инфраструктура переиспользуется

---

> **Детали реализации:** [Структура проекта](./project-structure.md), [MVVM паттерн](./modules/mvvm-pattern.md), [Создание модуля](./modules/creating-module.md)
