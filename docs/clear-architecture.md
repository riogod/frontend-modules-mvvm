# Чистая архитектура

Чистая архитектура (Clean Architecture) — это набор принципов проектирования программных систем, предложенный Робертом Мартином в одноименной книге. Цель подхода — создание систем, которые легко поддерживать, тестировать и развивать независимо от внешних фреймворков и технологий.

## Основная идея

Центральная идея чистой архитектуры — **разделение ответственности** и **независимость бизнес-логики** от деталей реализации. Бизнес-правила не должны зависеть от базы данных, UI-фреймворка или способа доставки данных пользователю.

## Слои архитектуры

Чистая архитектура организует код в концентрические слои, где каждый внутренний слой не знает о существовании внешних.

```
┌─────────────────────────────────────────────────────┐
│           Frameworks & Drivers                      │
│  (UI, база данных, веб-фреймворки, устройства)      │
│  ┌───────────────────────────────────────────────┐  │
│  │         Interface Adapters                    │  │
│  │  (контроллеры, презентеры, шлюзы)             │  │
│  │  ┌─────────────────────────────────────────┐  │  │
│  │  │         Application Business Rules      │  │  │
│  │  │              (Use Cases)                │  │  │
│  │  │  ┌───────────────────────────────────┐  │  │  │
│  │  │  │   Enterprise Business Rules       │  │  │  │
│  │  │  │         (Entities)                │  │  │  │
│  │  │  └───────────────────────────────────┘  │  │  │
│  │  └─────────────────────────────────────────┘  │  │
│  └───────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
```

### Entities (Сущности)

Самый внутренний слой содержит бизнес-сущности — объекты, инкапсулирующие критически важные бизнес-правила предприятия. Сущности не зависят ни от чего внешнего и могут использоваться в разных приложениях организации.

### Use Cases (Сценарии использования)

Слой содержит бизнес-правила конкретного приложения. Use Cases оркестрируют поток данных к сущностям и от них, направляя сущности на применение своих бизнес-правил для достижения целей сценария.

### Interface Adapters (Адаптеры интерфейсов)

Слой преобразует данные из формата, удобного для Use Cases и Entities, в формат, удобный для внешних агентов (база данных, веб). Здесь находятся контроллеры, презентеры и шлюзы (gateways).

### Frameworks & Drivers (Фреймворки и драйверы)

Самый внешний слой содержит фреймворки и инструменты: база данных, веб-фреймворк, UI-библиотеки. Этот слой — место, где все детали реализации. Код здесь минимален и служит связующим звеном с внутренними слоями.

## Правило зависимостей

**Зависимости в коде направлены только внутрь** — к центру диаграммы. Внутренние слои не знают ничего о внешних. Внешние слои могут ссылаться на внутренние, но не наоборот.

Это правило — фундамент чистой архитектуры:

- Сущности не знают о Use Cases
- Use Cases не знают о контроллерах и презентерах
- Адаптеры не знают о конкретных фреймворках

Когда внутреннему слою нужно обратиться к внешнему (например, Use Case должен сохранить данные), используется **инверсия зависимостей**: внутренний слой определяет интерфейс, а внешний слой его реализует.

## Принципы SOLID

Чистая архитектура опирается на принципы SOLID:

**Single Responsibility Principle (SRP)** — у класса должна быть только одна причина для изменения. Модуль отвечает только перед одной группой заинтересованных лиц.

**Open-Closed Principle (OCP)** — программные сущности открыты для расширения, но закрыты для модификации. Добавление нового поведения не требует изменения существующего кода.

**Liskov Substitution Principle (LSP)** — объекты подтипов должны быть взаимозаменяемы с объектами базового типа без нарушения корректности программы.

**Interface Segregation Principle (ISP)** — клиенты не должны зависеть от интерфейсов, которые они не используют. Лучше много специализированных интерфейсов, чем один универсальный.

**Dependency Inversion Principle (DIP)** — модули высокого уровня не должны зависеть от модулей низкого уровня. Оба должны зависеть от абстракций.

## Границы и компоненты

Архитектура определяет **границы** между компонентами системы. Граница — это линия, отделяющая компоненты друг от друга. Правильное проведение границ позволяет откладывать решения о деталях реализации.

Решения, которые можно отложить:
- Выбор базы данных
- Выбор веб-сервера
- Выбор UI-фреймворка
- Выбор библиотеки внедрения зависимостей

Бизнес-правила не должны зависеть от этих решений, и их изменение не должно требовать изменения бизнес-логики.

## Тестируемость

Одно из главных преимуществ чистой архитектуры — **тестируемость**. Бизнес-правила можно тестировать без UI, базы данных, веб-сервера или любого другого внешнего элемента.

Use Cases тестируются изолированно, подставляя моки вместо реальных репозиториев и шлюзов. Entities тестируются как чистые функции без каких-либо зависимостей.

## Независимость от фреймворков

Архитектура не зависит от существования какой-либо библиотеки. Фреймворки используются как инструменты, а не как основа системы. Это позволяет:

- Менять фреймворки без переписывания бизнес-логики
- Обновлять библиотеки без риска сломать приложение
- Использовать разные фреймворки для разных частей системы

## Поток данных

Данные пересекают границы в простых структурах. Не передавайте сущности базы данных или объекты фреймворка через границы. Используйте простые объекты передачи данных (DTO), оптимизированные для каждой границы.

Типичный поток:
1. Контроллер получает запрос и формирует входной DTO
2. Use Case получает DTO, выполняет бизнес-логику, возвращает выходной DTO
3. Презентер преобразует выходной DTO в формат для отображения

## Когда применять

Чистая архитектура оправдана для систем, которые:

- Будут развиваться длительное время
- Требуют высокой тестируемости
- Могут менять технологический стек
- Разрабатываются несколькими командами
- Содержат сложную бизнес-логику

Для небольших проектов и прототипов накладные расходы могут превышать преимущества.

## Итог

Чистая архитектура — это не строгий шаблон, а набор принципов. Главное — разделение ответственности, направление зависимостей к центру и независимость бизнес-логики от внешних деталей. Следование этим принципам создает системы, устойчивые к изменениям и легкие в поддержке.

---

> **Дополнительное чтение:** Robert C. Martin "Clean Architecture: A Craftsman's Guide to Software Structure and Design"

